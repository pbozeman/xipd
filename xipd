#!/usr/bin/env python3

# âœ¨ðŸ¤–âœ¨Vibe coded with Claude
#
# I didn't edit a single line of this code, other than this comment,
# and only did the most minimal of code review.
#
# I spot checked the report against the IBIS package files. If used for
# routing, I suggest you do the same.
#
# I wrote the design doc in the README.md, including the delay and length
# calculations (with help from ChatGPT). The design doc served as the blueprint
# and context for Claude's work here.

import argparse
import sys
import signal
from pathlib import Path
import re

# Handle broken pipe gracefully (when output is piped to head, less, etc.)
signal.signal(signal.SIGPIPE, signal.SIG_DFL)


def parse_args():
    parser = argparse.ArgumentParser(
        description="Compute package delays for Xilinx chips from IBIS files."
    )

    parser.add_argument(
        "package_file",
        type=Path,
        help="Path to the package file (e.g., 'ibis_files/artix7/xa7a12t_csg325.pkg')",
    )

    # PCB stack-up parameters for length calculation
    length_group = parser.add_argument_group(
        "PCB Stack-up Parameters for Length Calculation"
    )
    length_group.add_argument(
        "--dielectric-constant",
        "-d",
        type=float,
        help="Dielectric constant (Îµr) of the PCB substrate",
    )
    length_group.add_argument(
        "--prepreg-height",
        "-p",
        type=float,
        help="Height of prepreg (distance from trace to reference plane) - use same units as trace width",
    )
    length_group.add_argument(
        "--trace-width",
        "-w",
        type=float,
        help="Width of the microstrip trace - use same units as prepreg height",
    )
    length_group.add_argument(
        "--output-units",
        "-o",
        choices=["mm", "mils"],
        default="mils",
        help="Units for output trace lengths (default: mils)",
    )

    return parser.parse_args()


def parse_pin_numbers(file_path):
    """Parse the pin numbers section to extract pin to net mapping."""
    pin_map = {}
    in_pin_numbers = False

    with open(file_path, "r") as f:
        for line in f:
            line = line.strip()

            # Check if we're entering or leaving the Pin Numbers section
            if line == "[Pin Numbers]":
                in_pin_numbers = True
                continue
            elif in_pin_numbers and line.startswith("[") and line != "[Pin Name]":
                in_pin_numbers = False
                continue

            # Skip comments, empty lines, and header
            if (
                not in_pin_numbers
                or not line
                or line.startswith("|")
                or line.startswith("[Pin Name]")
            ):
                continue

            # Parse pin and net information
            parts = line.split()
            if len(parts) >= 3:  # Need at least pin name, net number, and net name
                pin_name = parts[0]

                # Find the net number position (preceded by '|')
                net_number_pos = -1
                for i, part in enumerate(parts):
                    if part == "|":
                        net_number_pos = i
                        break

                if net_number_pos >= 0 and net_number_pos + 2 < len(parts):
                    # The net name is typically after the net number
                    net_name = parts[net_number_pos + 2]
                    pin_map[pin_name] = net_name

    return pin_map


def parse_matrix_data(file_path, matrix_type):
    """Parse inductance or capacitance matrix data."""
    values = {}
    in_matrix = False
    current_row = None

    with open(file_path, "r") as f:
        for line in f:
            line = line.strip()

            # Check if we're entering the matrix section
            if line.startswith(f"[{matrix_type} Matrix]"):
                in_matrix = True
                continue
            elif in_matrix and line.startswith("[") and not line.startswith("[Row]"):
                in_matrix = False
                continue

            # Skip comments and empty lines
            if not in_matrix or not line or line.startswith("|"):
                continue

            # Skip "Sparse_matrix" line
            if "Sparse_matrix" in line:
                continue

            # Check for row header
            if line.startswith("[Row]"):
                parts = line.split()
                if len(parts) > 1:
                    current_row = parts[1]
                continue

            # Parse values
            if current_row:
                parts = line.split()
                if len(parts) >= 2:
                    col_name = parts[0]
                    try:
                        value = float(parts[1])

                        # For diagonal elements (self-inductance/capacitance)
                        if col_name == current_row:
                            values[col_name] = value
                    except ValueError:
                        pass

    return values


def calculate_delays(inductances, capacitances):
    """Calculate delays using the LC delay approximation: t_delay â‰ˆ âˆš(L Ã— C)."""
    delays = {}

    for pin in set(inductances.keys()) & set(capacitances.keys()):
        L = inductances[pin]
        C = capacitances[pin]
        # Calculate delay in seconds, convert to picoseconds
        delay_ps = 1e12 * (L * C) ** 0.5
        delays[pin] = delay_ps

    return delays


def convert_length_units(value, from_unit, to_unit):
    """Convert a length value between units.

    Args:
        value: The value to convert
        from_unit: Source unit ("mm" or "mils")
        to_unit: Target unit ("mm" or "mils")

    Returns:
        The value in the target unit
    """
    if from_unit == to_unit:
        return value

    # Convert to mm if needed
    if from_unit == "mils":
        value_mm = value * 0.0254  # 1 mil = 0.0254 mm
    else:
        value_mm = value

    # Convert from mm to target unit if needed
    if to_unit == "mils":
        return value_mm / 0.0254  # Convert mm to mils
    else:
        return value_mm  # Already in mm


def calculate_stripline_effective_dielectric(er):
    """Calculate effective dielectric constant for stripline.

    For stripline, effective dielectric constant equals the substrate's dielectric constant.
    """
    return er


def calculate_microstrip_effective_dielectric(er, h, w):
    """Calculate effective dielectric constant for microstrip.

    Args:
        er: Dielectric constant of substrate
        h: Height of dielectric (distance from trace to ground plane)
        w: Width of the trace

    Note: h and w must be in the same units

    Returns:
        Effective dielectric constant for microstrip
    """
    # For microstrip, use the approximation formula
    # Note: h/w is a ratio, so units cancel out as long as they're the same
    return (er + 1) / 2 + (er - 1) / 2 * (1 / (1 + 12 * h / w) ** 0.5)


def calculate_propagation_delay(effective_dielectric):
    """Calculate propagation delay per unit length.

    Args:
        effective_dielectric: Effective dielectric constant

    Returns:
        Propagation delay in seconds per meter
    """
    speed_of_light = 299792458  # meters per second
    # Calculate delay as t_d = sqrt(Îµ_eff) / c
    return (effective_dielectric**0.5) / speed_of_light


def calculate_trace_length(delay_ps, propagation_delay_s_m, output_unit="mm"):
    """Calculate trace length from delay and propagation delay.

    Args:
        delay_ps: Package delay in picoseconds
        propagation_delay_s_m: Propagation delay in seconds per meter
        output_unit: Output unit, either "mm" or "mils"

    Returns:
        Equivalent trace length in specified unit
    """
    # Convert delay from ps to seconds
    delay_s = delay_ps * 1e-12

    # Calculate length in meters
    length_m = delay_s / propagation_delay_s_m

    # Convert to mm first
    length_mm = length_m * 1000

    # Convert to requested output unit
    if output_unit == "mils":
        return convert_length_units(length_mm, "mm", "mils")
    else:
        return length_mm


def main():
    args = parse_args()

    # Verify the package file exists
    if not args.package_file.exists():
        print(f"Error: Package file not found: {args.package_file}", file=sys.stderr)
        return 1

    print(f"Processing package file: {args.package_file}")

    # Parse pin mapping
    pin_map = parse_pin_numbers(args.package_file)
    print(f"Found {len(pin_map)} pins in the pin map")

    # Parse inductance and capacitance matrices
    inductances = parse_matrix_data(args.package_file, "Inductance")
    capacitances = parse_matrix_data(args.package_file, "Capacitance")

    print(f"Found {len(inductances)} self-inductance values")
    print(f"Found {len(capacitances)} self-capacitance values")

    # Calculate delays
    delays = calculate_delays(inductances, capacitances)
    print(f"Calculated delays for {len(delays)} pins")

    # Calculate the max net name length for dynamic column sizing
    max_net_name_length = max([len(net) for net in pin_map.values()], default=20)
    # Ensure minimum width of 20 characters and add some padding
    net_name_width = max(20, max_net_name_length + 2)

    # Initialize variables for length calculations
    calculate_lengths = False
    stripline_delay = None
    microstrip_delay = None

    # Check if PCB stack-up parameters are provided for length calculations
    required_params = {"dielectric-constant", "prepreg-height", "trace-width"}
    provided_params = set()

    if args.dielectric_constant is not None:
        provided_params.add("dielectric-constant")
    if args.prepreg_height is not None:
        provided_params.add("prepreg-height")
    if args.trace_width is not None:
        provided_params.add("trace-width")

    # Check for partial parameters (some provided but not all)
    if 0 < len(provided_params) < len(required_params):
        # Some parameters provided but not all - show error
        missing_params = required_params - provided_params
        missing_args = [f"--{param}" for param in missing_params]
        print(
            "\nError: Incomplete stack-up and geometry information.",
            file=sys.stderr,
        )
        print(
            "Either provide ALL stack-up and geometry parameters or none at all.",
            file=sys.stderr,
        )
        print(
            f"Missing: {', '.join(missing_args)}",
            file=sys.stderr,
        )
        return 1

    if len(provided_params) == len(required_params):
        calculate_lengths = True

        # Calculate effective dielectric constants
        stripline_eff_er = calculate_stripline_effective_dielectric(
            args.dielectric_constant
        )
        microstrip_eff_er = calculate_microstrip_effective_dielectric(
            args.dielectric_constant, args.prepreg_height, args.trace_width
        )

        # Calculate propagation delays
        stripline_delay = calculate_propagation_delay(stripline_eff_er)
        microstrip_delay = calculate_propagation_delay(microstrip_eff_er)

        # Print stack-up information
        print(f"\nPCB Stack-up Parameters:")
        print(f"  Dielectric Constant (Îµr): {args.dielectric_constant:.2f}")
        print(f"  Prepreg Height: {args.prepreg_height:.2f}")
        print(f"  Trace Width: {args.trace_width:.2f}")
        print(f"  Height/Width Ratio: {args.prepreg_height/args.trace_width:.3f}")
        print(f"  Effective Dielectric (Stripline): {stripline_eff_er:.2f}")
        print(f"  Effective Dielectric (Microstrip): {microstrip_eff_er:.2f}")
        print(f"  Propagation Delay (Stripline): {stripline_delay * 1e12:.2f} ps/m")
        print(f"  Propagation Delay (Microstrip): {microstrip_delay * 1e12:.2f} ps/m")

    # Print pin data with delay, net name, inductance, and capacitance
    print("\nPin Data:\n")

    # Explicitly define the column widths - compact format for 80 columns
    col1_width = 8  # Pin Name
    col2_width = 7  # Delay (ps)
    col3_width = net_name_width  # Net Name (dynamically sized)
    col4_width = 12  # Inductance (H)
    col5_width = 12  # Capacitance (F)

    # Add columns for length calculations if parameters provided
    if calculate_lengths:
        col6_width = 12  # Stripline Length
        col7_width = 12  # Microstrip Length

        # Print header row 1 - column names
        header1 = (
            f"{'Pin':<{col1_width-2}}"
            f"{'Delay':<{col2_width+2}}"
            f"{'Stripline':<{col6_width+1}}"
            f"{'Microstrip':<{col7_width+1}}"
            f"{'Net Name':<{col3_width}}"
            f"{'Inductance':<{col4_width}}"
            f"{'Capacitance':<{col5_width}}"
        )
        # Print header row 2 - units
        header2 = (
            f"{'':<{col1_width-2}}"
            f"{'(ps)':<{col2_width+2}}"
            f"{'(' + args.output_units + ')':<{col6_width+1}}"
            f"{'(' + args.output_units + ')':<{col7_width+1}}"
            f"{'':<{col3_width}}"
            f"{'(H)':<{col4_width}}"
            f"{'(F)':<{col5_width}}"
        )
        print(header1)
        print(header2)
        print("-" * len(header1))
    else:
        # Print header row 1 - column names
        header1 = (
            f"{'Pin':<{col1_width-2}}"
            f"{'Delay':<{col2_width+2}}"
            f"{'Net Name':<{col3_width}}"
            f"{'Inductance':<{col4_width}}"
            f"{'Capacitance':<{col5_width}}"
        )
        # Print header row 2 - units
        header2 = (
            f"{'':<{col1_width-2}}"
            f"{'(ps)':<{col2_width+2}}"
            f"{'':<{col3_width}}"
            f"{'(H)':<{col4_width}}"
            f"{'(F)':<{col5_width}}"
        )
        print(header1)
        print(header2)
        print("-" * len(header1))

    for pin in sorted(pin_map.keys()):
        net = pin_map.get(pin, "N/A")
        inductance = inductances.get(pin, "N/A")
        capacitance = capacitances.get(pin, "N/A")
        delay = delays.get(pin, "N/A")

        if (
            isinstance(inductance, float)
            and isinstance(capacitance, float)
            and isinstance(delay, float)
        ):
            if calculate_lengths:
                # Calculate equivalent lengths
                stripline_length = calculate_trace_length(
                    delay, stripline_delay, args.output_units
                )
                microstrip_length = calculate_trace_length(
                    delay, microstrip_delay, args.output_units
                )

                print(
                    f"{pin:<{col1_width-2}}"
                    f"{delay:<{col2_width+2}.2f}"
                    f"{stripline_length:<{col6_width+1}.1f}"
                    f"{microstrip_length:<{col7_width+1}.1f}"
                    f"{net:<{col3_width}}"
                    f"{inductance:<{col4_width}.3e}"
                    f"{capacitance:<{col5_width}.3e}"
                )
            else:
                print(
                    f"{pin:<{col1_width-2}}"
                    f"{delay:<{col2_width+2}.2f}"
                    f"{net:<{col3_width}}"
                    f"{inductance:<{col4_width}.3e}"
                    f"{capacitance:<{col5_width}.3e}"
                )
        else:
            if calculate_lengths:
                print(
                    f"{pin:<{col1_width-2}}"
                    f"{'N/A':<{col2_width+2}}"
                    f"{'N/A':<{col6_width+1}}"
                    f"{'N/A':<{col7_width+1}}"
                    f"{net:<{col3_width}}"
                    f"{'N/A':<{col4_width}}"
                    f"{'N/A':<{col5_width}}"
                )
            else:
                print(
                    f"{pin:<{col1_width-2}}"
                    f"{'N/A':<{col2_width+2}}"
                    f"{net:<{col3_width}}"
                    f"{'N/A':<{col4_width}}"
                    f"{'N/A':<{col5_width}}"
                )

    return 0


if __name__ == "__main__":
    sys.exit(main())
